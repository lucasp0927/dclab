module traffic (/*AUTOARG*/
   // Outputs
   db, buttonlight, stoplight,
   // Inputs
   clk, button, stop_button, add_minus
   );

   parameter countersize = 6;
   // Local Variables:
   // verilog-auto-inst-param-value:t
   // End:
   
   input clk;
   input button;
   input stop_button;
   input [1:0] add_minus;
   
   output [9:0] db;
   output 	buttonlight;
   output 	stoplight;

   reg [countersize-1:0] 	counter; // every mode can have duration at most 32 secs
   reg [24:0] 	clks;
   reg [14:0] 	msclks;
   reg [21:0] 	clkfast; //1/8seconds
   reg [3:0] 	mode;
   reg [5:0] 	sec[9:0];
   reg  	next;
   reg [9:0] 	buttoncount;

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   wire			stop;			// From stop_oneshot1 of stop_oneshot.v
   // End of automatics
   
   /*AUTOREG*/
   // Beginning of automatic regs (for this module's undeclared outputs)
   reg			buttonlight;
   reg [9:0]		db;
   reg			stoplight;
   // End of automatics
   
   initial
     begin
	sec[0] = {{{countersize-4{1'b0}},4'd10}};
	sec[1] = {{{countersize-4{1'b0}},4'd10}};
	sec[2] = {{{countersize-4{1'b0}},4'd10}};
	sec[3] = {{{countersize-4{1'b0}},4'd10}};
	sec[4] = {{{countersize-4{1'b0}},4'd10}};
	sec[5] = {{{countersize-4{1'b0}},4'd10}};
	sec[6] = {{{countersize-4{1'b0}},4'd10}};
	sec[7] = {{{countersize-4{1'b0}},4'd10}};
	sec[8] = {{{countersize-4{1'b0}},4'd10}};
	sec[9] = {{{countersize-4{1'b0}},4'd10}};
     end // initial begin

   
   wire clksrc1_1; // phase lock loop
   clksrc clksrc1 ( , clk, clksrc1_1, );

   

   /* stop_oneshot AUTO_TEMPLATE (
    .clk (msclks[14]),
    );*/
   stop_oneshot stop_oneshot1 (/*AUTOINST*/
			       // Outputs
			       .stop		(stop),
			       // Inputs
			       .clk		(msclks[14]),	 // Templated
			       .stop_button	(stop_button));

   
   
   always @(*) begin // stoplight show whether the traffic light is paused.
      stoplight = stop;
   end

   always @ (posedge clksrc1_1) begin
      clks <= clks + 1'b1; 
      clkfast <= clkfast + 1'b1;
      msclks <= msclks + 1'b1;
   end

   always @(posedge clks[24]) begin // 1 sec
      if (stop == 1'b0) begin //not stop
	 if ((counter != 0) && (next  == 0) ) begin
	    counter <= counter - 1'b1;
	 end else begin
	    if (mode == 4'd9) begin
	       mode <= 4'd0;
	    end else begin
	       mode <= mode + 1'b1;   
	    end
	    case(mode)
	      4'd0: counter <= sec[1];
	      4'd1: counter <= sec[2];
	      4'd2: counter <= sec[3];
	      4'd3: counter <= sec[4];
	      4'd4: counter <= sec[5];
	      4'd5: counter <= sec[6];
	      4'd6: counter <= sec[7];
	      4'd7: counter <= sec[8];
	      4'd8: counter <= sec[9];
	      4'd9: counter <= sec[0];
	    endcase
	 end // always @ (posedge clks[24])
      end else begin // if (stop == 1'b0)  //stop
	 if (next == 1) begin
	    if (mode == 4'd9) begin
	       mode <= 4'd0;
	    end else begin
	       mode <= mode + 1'b1;   
	    end
	    case(mode)
	      4'd0: counter <= sec[1];
	      4'd1: counter <= sec[2];
	      4'd2: counter <= sec[3];
	      4'd3: counter <= sec[4];
	      4'd4: counter <= sec[5];
	      4'd5: counter <= sec[6];
	      4'd6: counter <= sec[7];
	      4'd7: counter <= sec[8];
	      4'd8: counter <= sec[9];
	      4'd9: counter <= sec[0];
	    endcase
	 end 
      end
   end

   always @(posedge clkfast[21]) begin 
      case(mode)
	4'd0 : db <= 10'b100000000;
	4'd1 :
	  if (db == 10'b0100000001) begin
	     db <= 10'b0000000001;
	  end else begin
	     db <= 10'b0100000001;
	  end
	4'd2: db = 10'b0010000000;
	4'd3: db = 10'b0001000000;
	4'd4: db = 10'b0000100000;
	4'd5: db = 10'b0000010000;
	4'd6: db = 10'b0000001000;
	4'd7: db = 10'b0000000100;
	4'd8: db = 10'b0000000010;
	4'd9: db = 10'b0000000001;     
      endcase 
   end

   always @(posedge msclks[14]) begin
      if (button == 0) begin
	 buttoncount <= 10'd1023;
	 next <= 1'b1;
      end else begin
	 if (buttoncount != 10'd0) begin
	    buttoncount <= buttoncount - 10'd1;
	 end else begin
	    buttoncount <= 10'd0;
	 end
      end
      if (buttoncount == 10'd0) begin
	 next <= 1'b0;
      end else begin
	 next <= 1'b1;
      end
   end
   always @(*) begin
      buttonlight = next;
   end // always @ begin

   // use a combinational curcuit to show the remain time or limit time
/*   always @(msclks[14]) begin
      
   end*/

   
endmodule // traffic

